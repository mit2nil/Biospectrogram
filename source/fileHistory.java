/*******************************************************************************
 *	This code does all the files related operations like
 *	1) Add new files to history
 *	2) Maintain latest files only in history
 *
 *	There are predefined three flags for all the codes corresponding
 *	three different kind of files
 *	1 for files fetched from internet
 *  2 for files gererated by different encodings
 *	3 for files generated by differernt transformations
 *  4 for files generated by export to matlab feature
 *  5 for files generated by window analysis for subsequences
 *	6 for files generated by window analysis for fetched from internet.
 *  7 for files generated by gene prediction feature
 *	8 for files generated by window analysis for transformation of subsequences
 *  9 for files generated by window analysis for matlab plotting
 *  10 for files generated by window analysis for encoding of subsequences
 *	11 for files generated by gene prediction for transformation of subsequences
 *	12 for files generated by gene prediction for matlab plotting
 *	13 for protein files fetched from from system
 *
 *	This code is written by Nilay Chheda @ daiict & Naman Turakhia @ daiict
 *	This code was last modified on 10th of September, 2012
 *
 *******************************************************************************/

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;

public class fileHistory
{
 	public fileHistory(int size,int flag)
    {
		maxSize = size;
        fileFlag = flag;
		updateFileList();
	}

	/*******************************************************************************
	 *	This method uses the flag provided in the constuctor and calls the
	 *	appropriate update file list method.
	*******************************************************************************/

	protected void updateFileList()
    {
		if (fileFlag == 1)
        {
			updateFetchedFileList();
		}
        else if (fileFlag == 2)
		{
        	updateEncodedFileList();
		}
        else if (fileFlag == 3)
		{
        	updateTransformedFileList();
		}
		else if (fileFlag == 4)
		{
        	updateProteinFileList();
		}
        //removeExtraFiles();
	}

	/*******************************************************************************
	 *	This method deletes old files from the history based on the maximal
	 *	allowable size.
	 *******************************************************************************/

	private void removeExtraFiles()
	{
	    if (fileFlag == 1)
	    {
			if (subdir1.listFiles () != null )
        	{
				File[] files = subdir1.listFiles();
            	int k = 0;
				//System.out.println(k);
            	//System.out.println(maxSize);
				//System.out.println(files.length);
            	if (maxSize < files.length)
				{
	            	//System.out.println (k);
                	//System.out.println (maxSize);
					//System.out.println (files.length);
                	for(k=maxSize;k < files.length;k++);
					{
	                	//System.out.println (k);
                    	//System.out.println (maxSize);
						//System.out.println (files.length);
						files[k].delete ();
					}
				}
			}
		}
    	else if (fileFlag == 2)
		{
	        // This method is not working correctly
		}
	}

	/*******************************************************************************
	 *	This method refresh the internal array of files in the fetched
	 *	files' directory, sort them according to time created or modified
	 *	and then add latest allowable number of files in the array
	 *******************************************************************************/

    protected void updateFetchedFileList()
	{
		subdir1 = new File("../History/Fetched");
		history = new ArrayList<File>();
    	if (subdir1.listFiles () != null )
        {

			File[] files = subdir1.listFiles();

            Pair[] pairs = new Pair[files.length];
			for (int i = 0; i < files.length; i++)
            {
            	//System.out.println(files[i].getName());
				pairs[i] = new Pair(files[i]);
			}

			// Sort them by timestamp.
            Arrays.sort(pairs);

			/*******************************************************************************
			 *	Loop variable initializes with total number of files at location,
			 *	decrements by one at every iteration till value 0 is hit and
			 *	adds the file in such way that the most recent files are at the
			 *	top of the array
			 *******************************************************************************/

			for (int i = files.length - 1; i >= 0; i--)
			{
            	// Take the sorted pairs and extract only the file part, discarding the timestamp.
                files[i] = pairs[i].f;
				addElement (files[i],files.length - 1 - i);
			}
		}
	}

	/*******************************************************************************
	 *	This method refresh the internal array of files in the encoded
	 *	files' directory, sort them according to time created or modified
	 *	and then add latest allowable number of files in the array
	 *******************************************************************************/

	protected void updateEncodedFileList()
	{
		subdir2 = new File("../History/Encoded");
		history = new ArrayList<File>();

    	if (subdir2.listFiles () != null )
        {
			File[] files = subdir2.listFiles();
            Pair[] pairs = new Pair[files.length];
			for (int i = 0; i < files.length; i++)
            {
				pairs[i] = new Pair(files[i]);
			}

			// Sort them by timestamp.
            Arrays.sort(pairs);

			/*******************************************************************************
			 *	Loop variable initializes with total number of files at location,
			 *	decrements by one at every iteration till value 0 is hit and
			 *	adds the file in such way that the most recent files are at the
			 *	top of the array
			 *******************************************************************************/

			for (int i = files.length - 1 ; i >= 0 ; i--)
			{
                // Take the sorted pairs and extract only the file part, discarding the timestamp.
				files[i] = pairs[i].f;
                addElement (files[i],files.length - 1 - i);
			}
		}
	}

	/*******************************************************************************
	 *	This method refresh the internal array of files in the transformed
	 *	files' directory, sort them according to time created or modified
	 *	and then add latest allowable number of files in the array
	 *******************************************************************************/

	protected void updateTransformedFileList()
	{
		subdir3 = new File("../History/Transformed");
		history = new ArrayList<File>();

    	if (subdir3.listFiles () != null )
        {
			File[] files = subdir3.listFiles();
            Pair[] pairs = new Pair[files.length];
			for (int i = 0; i < files.length; i++)
            {
				pairs[i] = new Pair(files[i]);
			}

            // Sort them by timestamp.
			Arrays.sort(pairs);


			/*******************************************************************************
			 *	Loop variable initializes with total number of files at location,
			 *	decrements by one at every iteration till value 0 is hit and
			 *	adds the file in such way that the most recent files are at the
			 *	top of the array
			 *******************************************************************************/

			for (int i = files.length - 1 ; i >= 0 ; i--)
			{
            	// Take the sorted pairs and extract only the file part, discarding the timestamp.
                files[i] = pairs[i].f;
				addElement (files[i],files.length - 1 - i);
			}
		}
	}

	protected void updateProteinFileList()
	{
		subdir13 = new File("../History/Protein");
		history = new ArrayList<File>();

    	if (subdir13.listFiles () != null )
        {
			File[] files = subdir13.listFiles();
            Pair[] pairs = new Pair[files.length];
			for (int i = 0; i < files.length; i++)
            {
				pairs[i] = new Pair(files[i]);
			}

            // Sort them by timestamp.
			Arrays.sort(pairs);


			/*******************************************************************************
			 *	Loop variable initializes with total number of files at location,
			 *	decrements by one at every iteration till value 0 is hit and
			 *	adds the file in such way that the most recent files are at the
			 *	top of the array
			 *******************************************************************************/

			for (int i = files.length - 1 ; i >= 0 ; i--)
			{
            	// Take the sorted pairs and extract only the file part, discarding the timestamp.
                files[i] = pairs[i].f;
				addElement (files[i],files.length - 1 - i);
			}
		}
	}

	/*******************************************************************************
	 *	This methid can change the maximum allowable number of files in
	 *	history. This count is applicable for encoded and transformed file list
	 *	as well.
	 *******************************************************************************/

	protected void changeSize(int a)
	{
    	maxSize = a;
    	for(int i=maxSize;i<history.size();i++)
    	{
    		history.get(i).delete();
    	}
        updateFileList ();
	}

	/*******************************************************************************
	 *	This method adds file  f in the history at given index if size of the history
	 *	doesnot exceed threshold.
	 *******************************************************************************/

	private  void addElement(File f,int index)
    {
		if (index < maxSize )
        {
			if ( history.size () < maxSize )
            {
				// simply add an element at the end of the array
                if (index < history.size ())
				{
                	history.remove (index);
				}
                history.add(index,f);
			}
            else
			{
            	// remove a first inserted element, shift entire array by one position then add the new element at the end
                history.remove(0);
				if (index < history.size ())
                {
                    history.remove (index);
				}
                history.add(index,f);
			}
		}
	}

	/*******************************************************************************
	 *	This method prints the current content of the array that is list of
	 *	files that exist in the history.
	 *******************************************************************************/

	protected void printArray()
	{
    	for(int i=0;i<history.size ();i++)
        {
			System.out.println(history.get(i).getName());
		}
	}

	/*******************************************************************************
	 *	This method returns all the elements of the array that is list of files
	 *	in a new array of strings.
	 *******************************************************************************/

	protected String[] getArray()
	{
    	if (history.size() != 0)
        {
			String[] list = new String[history.size ()];

			for(int j=0;j<history.size ();j++)
            {
				File f = history.get(j);
                list[j] = f.getName ();
			}
            return list;
		}
        else
		{
        	String[] list = new String[1];
            list[0] = "List is empty";
			return list;
		}
	}

	/*******************************************************************************
	 *	This method returns current size of the history
	*******************************************************************************/

    protected int getSize()
	{
    	return this.history.size();
	}

	/*******************************************************************************
	 *	This method returns maximum size allowed in the history
	 *******************************************************************************/

    protected int getMaxSize()
	{
    	return this.maxSize;
	}

	/*******************************************************************************
	 *	This method returns element of the array that is a file located at the
	 *	index provided as parameter.
	 *******************************************************************************/

	protected File getElement(int index)
	{
		if (index<maxSize)
        {
			File f = history.get(index);
            return f;
		}
        else
		{
        	return null;
		}
	}

	/*******************************************************************************
	 *	This method returns the size of the direcory where history is saved
	 *	so that user can delete some files or change the maximum files in
	 *	history
	 *	index provided as parameter. (1 for fetch , 2 for encode and
	 *	3 for transformation & 4 for protein as usual)
	 *******************************************************************************/

	protected static long getDirSize(int index)
	{
    	String path="";
        long size=0;
		if (index == 1)
        {
			path = "../History/Fetched";
		}
        else if (index == 2)
		{
        	path = "../History/Encoded";
		}
        else if (index == 3)
		{
        	path = "../History/Transformed";
		}
		else if (index == 4)
		{
			path = "../History/Protein";
		}
        File folder = new File(path);
		File[] filelist = folder.listFiles ();
        for(int i=0;i<filelist.length;i++)
		{
        	if (!filelist[i].isDirectory ())
            {
				size = size + filelist[i].length ();
			}
		}
        return size;
	}

	/*******************************************************************************
	 *	This is an inner class that sorts the file list according to
	 *	date added or modified.
	 *******************************************************************************/

    class Pair implements Comparable
	{
    	public Pair(File file)
        {
			f = file;
            t = file.lastModified ();
		}

        public int compareTo(Object o)
		{
        	long u = ((Pair) o).t;

			/*******************************************************************************
			 *	This condition compares t with u and returns -1
			 *	if t<u 0 if both are equal and 1 other wise.
			 *******************************************************************************/

             return t < u ? -1 : t == u ? 0 : 1;
		}

        public long t;
		public File f;
	}

    private int fileFlag;
	private int maxSize;
    private ArrayList<File> history = new ArrayList<File>();
	protected static File dir = new File("../History");
    protected static File subdir1 = new File("../History/Fetched");
	protected static File subdir2 = new File("../History/Encoded");
    protected static File subdir3 = new File("../History/Transformed");
	protected static File subdir4 = new File("../History/Matlab_Files");
	protected static File subdir5 = new File("../History/Window_Analysis");
	protected static File subdir6 = new File("../History/Window_Analysis/Fetched");
	protected static File subdir7 = new File("../History/Gene_Prediction");
	protected static File subdir8 = new File("../History/Window_Analysis/Transformed");
	protected static File subdir9 = new File("../History/Window_Analysis/Matlab_Files");
	protected static File subdir10 = new File("../History/Window_Analysis/Encoded");
	protected static File subdir11 = new File("../History/Gene_Prediction/Transformed");
	protected static File subdir12 = new File("../History/Gene_Prediction/Matlab_Files");
	protected static File subdir13 = new File("../History/Protein");
}